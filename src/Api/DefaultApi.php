<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  Wrike\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Wrike REST API
 *
 * Definition of the [Wrike API 3.0](https://developers.wrike.com/documentation/api/overview).
 *
 * OpenAPI spec version: 1.1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Wrike\Client\Api;

use \Wrike\Client\ApiClient;
use \Wrike\Client\ApiException;
use \Wrike\Client\Configuration;
use \Wrike\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Wrike\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * API Client
     *
     * @var \Wrike\Client\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \Wrike\Client\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\Wrike\Client\ApiClient $apiClient = null)
    {
        if ($apiClient === null) {
            $apiClient = new ApiClient();
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \Wrike\Client\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \Wrike\Client\ApiClient $apiClient set the API client
     *
     * @return DefaultApi
     */
    public function setApiClient(\Wrike\Client\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation getContacts
     *
     * 
     *
     * @param bool $me If present - only contact info of requesting user is returned (optional)
     * @param string $metadata Metadata filter, exact match for metadata key or key-value pair (optional)
     * @param string $fields Json string array of optional fields to be included in the response model (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return \Wrike\Client\Model\InlineResponse200
     */
    public function getContacts($me = null, $metadata = null, $fields = null)
    {
        list($response) = $this->getContactsWithHttpInfo($me, $metadata, $fields);
        return $response;
    }

    /**
     * Operation getContactsWithHttpInfo
     *
     * 
     *
     * @param bool $me If present - only contact info of requesting user is returned (optional)
     * @param string $metadata Metadata filter, exact match for metadata key or key-value pair (optional)
     * @param string $fields Json string array of optional fields to be included in the response model (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return array of \Wrike\Client\Model\InlineResponse200, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactsWithHttpInfo($me = null, $metadata = null, $fields = null)
    {
        // parse inputs
        $resourcePath = "/contacts";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($me !== null) {
            $queryParams['me'] = $this->apiClient->getSerializer()->toQueryValue($me);
        }
        // query params
        if ($metadata !== null) {
            $queryParams['metadata'] = $this->apiClient->getSerializer()->toQueryValue($metadata);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = $this->apiClient->getSerializer()->toQueryValue($fields);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Wrike\Client\Model\InlineResponse200',
                '/contacts'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\Wrike\Client\Model\InlineResponse200', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\InlineResponse200', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getContactsById
     *
     * 
     *
     * @param string[] $contact_id If present - only contact info of requesting user is returned (required)
     * @param string $metadata Metadata filter, exact match for metadata key or key-value pair (optional)
     * @param string $fields Json string array of optional fields to be included in the response model (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return \Wrike\Client\Model\InlineResponse200
     */
    public function getContactsById($contact_id, $metadata = null, $fields = null)
    {
        list($response) = $this->getContactsByIdWithHttpInfo($contact_id, $metadata, $fields);
        return $response;
    }

    /**
     * Operation getContactsByIdWithHttpInfo
     *
     * 
     *
     * @param string[] $contact_id If present - only contact info of requesting user is returned (required)
     * @param string $metadata Metadata filter, exact match for metadata key or key-value pair (optional)
     * @param string $fields Json string array of optional fields to be included in the response model (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return array of \Wrike\Client\Model\InlineResponse200, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactsByIdWithHttpInfo($contact_id, $metadata = null, $fields = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $contact_id when calling getContactsById');
        }
        // parse inputs
        $resourcePath = "/contacts/{contactId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($metadata !== null) {
            $queryParams['metadata'] = $this->apiClient->getSerializer()->toQueryValue($metadata);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = $this->apiClient->getSerializer()->toQueryValue($fields);
        }
        // path params
        if (is_array($contact_id)) {
            $contact_id = $this->apiClient->getSerializer()->serializeCollection($contact_id, 'csv');
        }
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                "{" . "contactId" . "}",
                $this->apiClient->getSerializer()->toPathValue($contact_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Wrike\Client\Model\InlineResponse200',
                '/contacts/{contactId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\Wrike\Client\Model\InlineResponse200', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\InlineResponse200', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getFolders
     *
     * 
     *
     * @param string $permalink Folder permalink, exact match (optional)
     * @param bool $descendants Adds all descendant folders to search scope (optional)
     * @param string $metadata Metadata filter, exact match for metadata key or key-value pair (optional)
     * @param string $custom_field Custom field filter (id/value). JSON object with &#39;id&#39; and &#39;value&#39; properties. (optional)
     * @param string $updated_date Updated date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $project Get only projects (true) / only folders (false) (optional)
     * @param bool $deleted Get folders from Root (false) / Recycle Bin (true) (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return \Wrike\Client\Model\InlineResponse2001
     */
    public function getFolders($permalink = null, $descendants = null, $metadata = null, $custom_field = null, $updated_date = null, $project = null, $deleted = null)
    {
        list($response) = $this->getFoldersWithHttpInfo($permalink, $descendants, $metadata, $custom_field, $updated_date, $project, $deleted);
        return $response;
    }

    /**
     * Operation getFoldersWithHttpInfo
     *
     * 
     *
     * @param string $permalink Folder permalink, exact match (optional)
     * @param bool $descendants Adds all descendant folders to search scope (optional)
     * @param string $metadata Metadata filter, exact match for metadata key or key-value pair (optional)
     * @param string $custom_field Custom field filter (id/value). JSON object with &#39;id&#39; and &#39;value&#39; properties. (optional)
     * @param string $updated_date Updated date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $project Get only projects (true) / only folders (false) (optional)
     * @param bool $deleted Get folders from Root (false) / Recycle Bin (true) (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return array of \Wrike\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFoldersWithHttpInfo($permalink = null, $descendants = null, $metadata = null, $custom_field = null, $updated_date = null, $project = null, $deleted = null)
    {
        // parse inputs
        $resourcePath = "/folders";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($permalink !== null) {
            $queryParams['permalink'] = $this->apiClient->getSerializer()->toQueryValue($permalink);
        }
        // query params
        if ($descendants !== null) {
            $queryParams['descendants'] = $this->apiClient->getSerializer()->toQueryValue($descendants);
        }
        // query params
        if ($metadata !== null) {
            $queryParams['metadata'] = $this->apiClient->getSerializer()->toQueryValue($metadata);
        }
        // query params
        if ($custom_field !== null) {
            $queryParams['customField'] = $this->apiClient->getSerializer()->toQueryValue($custom_field);
        }
        // query params
        if ($updated_date !== null) {
            $queryParams['updatedDate'] = $this->apiClient->getSerializer()->toQueryValue($updated_date);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = $this->apiClient->getSerializer()->toQueryValue($project);
        }
        // query params
        if ($deleted !== null) {
            $queryParams['deleted'] = $this->apiClient->getSerializer()->toQueryValue($deleted);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Wrike\Client\Model\InlineResponse2001',
                '/folders'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\Wrike\Client\Model\InlineResponse2001', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\InlineResponse2001', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getFoldersFromFolderId
     *
     * 
     *
     * @param string $folder_id The folder ID (required)
     * @param string $permalink Folder permalink, exact match (optional)
     * @param bool $descendants Adds all descendant folders to search scope (optional)
     * @param string $metadata Metadata filter, exact match for metadata key or key-value pair (optional)
     * @param string $custom_field Custom field filter (id/value) (optional)
     * @param string $updated_date Updated date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $project Get only projects (true) / only folders (false) (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return \Wrike\Client\Model\InlineResponse2001
     */
    public function getFoldersFromFolderId($folder_id, $permalink = null, $descendants = null, $metadata = null, $custom_field = null, $updated_date = null, $project = null)
    {
        list($response) = $this->getFoldersFromFolderIdWithHttpInfo($folder_id, $permalink, $descendants, $metadata, $custom_field, $updated_date, $project);
        return $response;
    }

    /**
     * Operation getFoldersFromFolderIdWithHttpInfo
     *
     * 
     *
     * @param string $folder_id The folder ID (required)
     * @param string $permalink Folder permalink, exact match (optional)
     * @param bool $descendants Adds all descendant folders to search scope (optional)
     * @param string $metadata Metadata filter, exact match for metadata key or key-value pair (optional)
     * @param string $custom_field Custom field filter (id/value) (optional)
     * @param string $updated_date Updated date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $project Get only projects (true) / only folders (false) (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return array of \Wrike\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFoldersFromFolderIdWithHttpInfo($folder_id, $permalink = null, $descendants = null, $metadata = null, $custom_field = null, $updated_date = null, $project = null)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $folder_id when calling getFoldersFromFolderId');
        }
        // parse inputs
        $resourcePath = "/folders/{folderId}/folders";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($permalink !== null) {
            $queryParams['permalink'] = $this->apiClient->getSerializer()->toQueryValue($permalink);
        }
        // query params
        if ($descendants !== null) {
            $queryParams['descendants'] = $this->apiClient->getSerializer()->toQueryValue($descendants);
        }
        // query params
        if ($metadata !== null) {
            $queryParams['metadata'] = $this->apiClient->getSerializer()->toQueryValue($metadata);
        }
        // query params
        if ($custom_field !== null) {
            $queryParams['customField'] = $this->apiClient->getSerializer()->toQueryValue($custom_field);
        }
        // query params
        if ($updated_date !== null) {
            $queryParams['updatedDate'] = $this->apiClient->getSerializer()->toQueryValue($updated_date);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = $this->apiClient->getSerializer()->toQueryValue($project);
        }
        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                "{" . "folderId" . "}",
                $this->apiClient->getSerializer()->toPathValue($folder_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Wrike\Client\Model\InlineResponse2001',
                '/folders/{folderId}/folders'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\Wrike\Client\Model\InlineResponse2001', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\InlineResponse2001', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getTasks
     *
     * 
     *
     * @param string[] $authors Authors filter, match of any (required)
     * @param string[] $responsibles Responsibles filter, match of any (required)
     * @param string[] $shareds Shared users filter, match of any (required)
     * @param bool $descendants Adds all descendant folders to search scope (optional)
     * @param string $title Title filter, exact match (optional)
     * @param string $status Status filter, match with any of specified constants (optional)
     * @param string $importance Importance filter, exact match. (optional)
     * @param string $start_date Start date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $due_date Due date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $scheduled_date Scheduled date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $created_date Created date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $updated_date Updated date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $completed_date Completed date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $permalink Task permalink, exact match (optional)
     * @param string $type Task type. (optional)
     * @param int $limit Limit on number of returned tasks (optional)
     * @param string $sort_field Sort field. (optional)
     * @param string $sort_order Sort order. (optional, default to Asc)
     * @param bool $sub_tasks Adds subtasks to search scope (optional)
     * @param float $page_size Page size (optional)
     * @param string $next_page_token Next page token, overrides any other parameters in request. (optional)
     * @param string $metadata Metadata filter, exact match for metadata key or key-value pair (optional)
     * @param string $custom_field Custom field filter (id/value). JSON object with &#39;id&#39; and &#39;value&#39; properties. (optional)
     * @param string $custom_statuses Custom statuses filter. JSON array with a list of Custom status IDs. (optional)
     * @param string $fields \&quot;Json string array of optional fields to be included in the response model.\&quot; \&quot;Available fields: \\n\&quot; \&quot;- authorIds: Author IDs\&quot; \&quot;- hasAttachments: Has attachments\&quot; \&quot;- attachmentCount: Attachment count\&quot; \&quot;- parentIds: List of task parent folder\&quot; \&quot;- superParentIds: List of task super parent folder\&quot; \&quot;- sharedIds: List of user IDs, who have task share\&quot; \&quot;- responsibleIds: List of responsible user IDs\&quot; \&quot;- description: Description\&quot; \&quot;- briefDescription: Brief description\&quot; \&quot;- recurrent: Is a task recurrent\&quot; \&quot;- superTaskIds: List of supertask IDs\&quot; \&quot;- subTaskIds: List of subtask IDs\&quot; \&quot;- dependencyIds: Dependency IDs\&quot; \&quot;- metadata: Task metadata entries\&quot; \&quot;- customFields: Custom fields\&quot; (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return \Wrike\Client\Model\InlineResponse2002
     */
    public function getTasks($authors, $responsibles, $shareds, $descendants = null, $title = null, $status = null, $importance = null, $start_date = null, $due_date = null, $scheduled_date = null, $created_date = null, $updated_date = null, $completed_date = null, $permalink = null, $type = null, $limit = null, $sort_field = null, $sort_order = null, $sub_tasks = null, $page_size = null, $next_page_token = null, $metadata = null, $custom_field = null, $custom_statuses = null, $fields = null)
    {
        list($response) = $this->getTasksWithHttpInfo($authors, $responsibles, $shareds, $descendants, $title, $status, $importance, $start_date, $due_date, $scheduled_date, $created_date, $updated_date, $completed_date, $permalink, $type, $limit, $sort_field, $sort_order, $sub_tasks, $page_size, $next_page_token, $metadata, $custom_field, $custom_statuses, $fields);
        return $response;
    }

    /**
     * Operation getTasksWithHttpInfo
     *
     * 
     *
     * @param string[] $authors Authors filter, match of any (required)
     * @param string[] $responsibles Responsibles filter, match of any (required)
     * @param string[] $shareds Shared users filter, match of any (required)
     * @param bool $descendants Adds all descendant folders to search scope (optional)
     * @param string $title Title filter, exact match (optional)
     * @param string $status Status filter, match with any of specified constants (optional)
     * @param string $importance Importance filter, exact match. (optional)
     * @param string $start_date Start date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $due_date Due date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $scheduled_date Scheduled date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $created_date Created date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $updated_date Updated date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $completed_date Completed date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $permalink Task permalink, exact match (optional)
     * @param string $type Task type. (optional)
     * @param int $limit Limit on number of returned tasks (optional)
     * @param string $sort_field Sort field. (optional)
     * @param string $sort_order Sort order. (optional, default to Asc)
     * @param bool $sub_tasks Adds subtasks to search scope (optional)
     * @param float $page_size Page size (optional)
     * @param string $next_page_token Next page token, overrides any other parameters in request. (optional)
     * @param string $metadata Metadata filter, exact match for metadata key or key-value pair (optional)
     * @param string $custom_field Custom field filter (id/value). JSON object with &#39;id&#39; and &#39;value&#39; properties. (optional)
     * @param string $custom_statuses Custom statuses filter. JSON array with a list of Custom status IDs. (optional)
     * @param string $fields \&quot;Json string array of optional fields to be included in the response model.\&quot; \&quot;Available fields: \\n\&quot; \&quot;- authorIds: Author IDs\&quot; \&quot;- hasAttachments: Has attachments\&quot; \&quot;- attachmentCount: Attachment count\&quot; \&quot;- parentIds: List of task parent folder\&quot; \&quot;- superParentIds: List of task super parent folder\&quot; \&quot;- sharedIds: List of user IDs, who have task share\&quot; \&quot;- responsibleIds: List of responsible user IDs\&quot; \&quot;- description: Description\&quot; \&quot;- briefDescription: Brief description\&quot; \&quot;- recurrent: Is a task recurrent\&quot; \&quot;- superTaskIds: List of supertask IDs\&quot; \&quot;- subTaskIds: List of subtask IDs\&quot; \&quot;- dependencyIds: Dependency IDs\&quot; \&quot;- metadata: Task metadata entries\&quot; \&quot;- customFields: Custom fields\&quot; (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return array of \Wrike\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTasksWithHttpInfo($authors, $responsibles, $shareds, $descendants = null, $title = null, $status = null, $importance = null, $start_date = null, $due_date = null, $scheduled_date = null, $created_date = null, $updated_date = null, $completed_date = null, $permalink = null, $type = null, $limit = null, $sort_field = null, $sort_order = null, $sub_tasks = null, $page_size = null, $next_page_token = null, $metadata = null, $custom_field = null, $custom_statuses = null, $fields = null)
    {
        // verify the required parameter 'authors' is set
        if ($authors === null) {
            throw new \InvalidArgumentException('Missing the required parameter $authors when calling getTasks');
        }
        // verify the required parameter 'responsibles' is set
        if ($responsibles === null) {
            throw new \InvalidArgumentException('Missing the required parameter $responsibles when calling getTasks');
        }
        // verify the required parameter 'shareds' is set
        if ($shareds === null) {
            throw new \InvalidArgumentException('Missing the required parameter $shareds when calling getTasks');
        }
        // parse inputs
        $resourcePath = "/tasks";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($descendants !== null) {
            $queryParams['descendants'] = $this->apiClient->getSerializer()->toQueryValue($descendants);
        }
        // query params
        if ($title !== null) {
            $queryParams['title'] = $this->apiClient->getSerializer()->toQueryValue($title);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = $this->apiClient->getSerializer()->toQueryValue($status);
        }
        // query params
        if ($importance !== null) {
            $queryParams['importance'] = $this->apiClient->getSerializer()->toQueryValue($importance);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['startDate'] = $this->apiClient->getSerializer()->toQueryValue($start_date);
        }
        // query params
        if ($due_date !== null) {
            $queryParams['dueDate'] = $this->apiClient->getSerializer()->toQueryValue($due_date);
        }
        // query params
        if ($scheduled_date !== null) {
            $queryParams['scheduledDate'] = $this->apiClient->getSerializer()->toQueryValue($scheduled_date);
        }
        // query params
        if ($created_date !== null) {
            $queryParams['createdDate'] = $this->apiClient->getSerializer()->toQueryValue($created_date);
        }
        // query params
        if ($updated_date !== null) {
            $queryParams['updatedDate'] = $this->apiClient->getSerializer()->toQueryValue($updated_date);
        }
        // query params
        if ($completed_date !== null) {
            $queryParams['completedDate'] = $this->apiClient->getSerializer()->toQueryValue($completed_date);
        }
        // query params
        if (is_array($authors)) {
            $authors = $this->apiClient->getSerializer()->serializeCollection($authors, 'csv', true);
        }
        if ($authors !== null) {
            $queryParams['authors'] = $this->apiClient->getSerializer()->toQueryValue($authors);
        }
        // query params
        if (is_array($responsibles)) {
            $responsibles = $this->apiClient->getSerializer()->serializeCollection($responsibles, 'csv', true);
        }
        if ($responsibles !== null) {
            $queryParams['responsibles'] = $this->apiClient->getSerializer()->toQueryValue($responsibles);
        }
        // query params
        if (is_array($shareds)) {
            $shareds = $this->apiClient->getSerializer()->serializeCollection($shareds, 'csv', true);
        }
        if ($shareds !== null) {
            $queryParams['shareds'] = $this->apiClient->getSerializer()->toQueryValue($shareds);
        }
        // query params
        if ($permalink !== null) {
            $queryParams['permalink'] = $this->apiClient->getSerializer()->toQueryValue($permalink);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = $this->apiClient->getSerializer()->toQueryValue($type);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = $this->apiClient->getSerializer()->toQueryValue($limit);
        }
        // query params
        if ($sort_field !== null) {
            $queryParams['sortField'] = $this->apiClient->getSerializer()->toQueryValue($sort_field);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $this->apiClient->getSerializer()->toQueryValue($sort_order);
        }
        // query params
        if ($sub_tasks !== null) {
            $queryParams['subTasks'] = $this->apiClient->getSerializer()->toQueryValue($sub_tasks);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = $this->apiClient->getSerializer()->toQueryValue($page_size);
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['nextPageToken'] = $this->apiClient->getSerializer()->toQueryValue($next_page_token);
        }
        // query params
        if ($metadata !== null) {
            $queryParams['metadata'] = $this->apiClient->getSerializer()->toQueryValue($metadata);
        }
        // query params
        if ($custom_field !== null) {
            $queryParams['customField'] = $this->apiClient->getSerializer()->toQueryValue($custom_field);
        }
        // query params
        if ($custom_statuses !== null) {
            $queryParams['customStatuses'] = $this->apiClient->getSerializer()->toQueryValue($custom_statuses);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = $this->apiClient->getSerializer()->toQueryValue($fields);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Wrike\Client\Model\InlineResponse2002',
                '/tasks'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\Wrike\Client\Model\InlineResponse2002', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\InlineResponse2002', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getTasksById
     *
     * 
     *
     * @param string[] $task_id A list of task IDS - up to 100 IDs (required)
     * @param string $fields \&quot;Json string array of optional fields to be included in the response model.\&quot; \&quot;Available fields: \\n\&quot; \&quot;- recurrent: Add field to indicate if task is recurrent\&quot; \&quot;- attachmentCount: Attachment count\&quot; (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return \Wrike\Client\Model\InlineResponse2002
     */
    public function getTasksById($task_id, $fields = null)
    {
        list($response) = $this->getTasksByIdWithHttpInfo($task_id, $fields);
        return $response;
    }

    /**
     * Operation getTasksByIdWithHttpInfo
     *
     * 
     *
     * @param string[] $task_id A list of task IDS - up to 100 IDs (required)
     * @param string $fields \&quot;Json string array of optional fields to be included in the response model.\&quot; \&quot;Available fields: \\n\&quot; \&quot;- recurrent: Add field to indicate if task is recurrent\&quot; \&quot;- attachmentCount: Attachment count\&quot; (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return array of \Wrike\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTasksByIdWithHttpInfo($task_id, $fields = null)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $task_id when calling getTasksById');
        }
        // parse inputs
        $resourcePath = "/tasks/{taskId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = $this->apiClient->getSerializer()->toQueryValue($fields);
        }
        // path params
        if (is_array($task_id)) {
            $task_id = $this->apiClient->getSerializer()->serializeCollection($task_id, 'csv');
        }
        if ($task_id !== null) {
            $resourcePath = str_replace(
                "{" . "taskId" . "}",
                $this->apiClient->getSerializer()->toPathValue($task_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Wrike\Client\Model\InlineResponse2002',
                '/tasks/{taskId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\Wrike\Client\Model\InlineResponse2002', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\InlineResponse2002', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getTimelogs
     *
     * 
     *
     * @param string $created_date Created date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $tracked_date Tracked date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $me If present - only contact info of requesting user is returned (optional)
     * @param bool $descendants Adds all descendant tasks to search scope (optional, default to true)
     * @param bool $sub_tasks Adds subtasks to search scope (optional, default to true)
     * @param bool $plain_text Get comment text as plain text, HTML otherwise (optional, default to false)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return \Wrike\Client\Model\InlineResponse2003
     */
    public function getTimelogs($created_date = null, $tracked_date = null, $me = null, $descendants = null, $sub_tasks = null, $plain_text = null)
    {
        list($response) = $this->getTimelogsWithHttpInfo($created_date, $tracked_date, $me, $descendants, $sub_tasks, $plain_text);
        return $response;
    }

    /**
     * Operation getTimelogsWithHttpInfo
     *
     * 
     *
     * @param string $created_date Created date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $tracked_date Tracked date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $me If present - only contact info of requesting user is returned (optional)
     * @param bool $descendants Adds all descendant tasks to search scope (optional, default to true)
     * @param bool $sub_tasks Adds subtasks to search scope (optional, default to true)
     * @param bool $plain_text Get comment text as plain text, HTML otherwise (optional, default to false)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return array of \Wrike\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTimelogsWithHttpInfo($created_date = null, $tracked_date = null, $me = null, $descendants = null, $sub_tasks = null, $plain_text = null)
    {
        // parse inputs
        $resourcePath = "/timelogs";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($created_date !== null) {
            $queryParams['createdDate'] = $this->apiClient->getSerializer()->toQueryValue($created_date);
        }
        // query params
        if ($tracked_date !== null) {
            $queryParams['trackedDate'] = $this->apiClient->getSerializer()->toQueryValue($tracked_date);
        }
        // query params
        if ($me !== null) {
            $queryParams['me'] = $this->apiClient->getSerializer()->toQueryValue($me);
        }
        // query params
        if ($descendants !== null) {
            $queryParams['descendants'] = $this->apiClient->getSerializer()->toQueryValue($descendants);
        }
        // query params
        if ($sub_tasks !== null) {
            $queryParams['subTasks'] = $this->apiClient->getSerializer()->toQueryValue($sub_tasks);
        }
        // query params
        if ($plain_text !== null) {
            $queryParams['plainText'] = $this->apiClient->getSerializer()->toQueryValue($plain_text);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Wrike\Client\Model\InlineResponse2003',
                '/timelogs'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\Wrike\Client\Model\InlineResponse2003', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\InlineResponse2003', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getTimelogsForAccount
     *
     * 
     *
     * @param string $account_id The contact ID (required)
     * @param string $created_date Created date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $tracked_date Tracked date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $me If present - only contact info of requesting user is returned (optional)
     * @param bool $descendants Adds all descendant tasks to search scope (optional, default to true)
     * @param bool $sub_tasks Adds subtasks to search scope (optional, default to true)
     * @param bool $plain_text Get comment text as plain text, HTML otherwise (optional, default to false)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return \Wrike\Client\Model\InlineResponse2003
     */
    public function getTimelogsForAccount($account_id, $created_date = null, $tracked_date = null, $me = null, $descendants = null, $sub_tasks = null, $plain_text = null)
    {
        list($response) = $this->getTimelogsForAccountWithHttpInfo($account_id, $created_date, $tracked_date, $me, $descendants, $sub_tasks, $plain_text);
        return $response;
    }

    /**
     * Operation getTimelogsForAccountWithHttpInfo
     *
     * 
     *
     * @param string $account_id The contact ID (required)
     * @param string $created_date Created date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $tracked_date Tracked date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $me If present - only contact info of requesting user is returned (optional)
     * @param bool $descendants Adds all descendant tasks to search scope (optional, default to true)
     * @param bool $sub_tasks Adds subtasks to search scope (optional, default to true)
     * @param bool $plain_text Get comment text as plain text, HTML otherwise (optional, default to false)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return array of \Wrike\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTimelogsForAccountWithHttpInfo($account_id, $created_date = null, $tracked_date = null, $me = null, $descendants = null, $sub_tasks = null, $plain_text = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getTimelogsForAccount');
        }
        // parse inputs
        $resourcePath = "/accounts/{accountId}/timelogs";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($created_date !== null) {
            $queryParams['createdDate'] = $this->apiClient->getSerializer()->toQueryValue($created_date);
        }
        // query params
        if ($tracked_date !== null) {
            $queryParams['trackedDate'] = $this->apiClient->getSerializer()->toQueryValue($tracked_date);
        }
        // query params
        if ($me !== null) {
            $queryParams['me'] = $this->apiClient->getSerializer()->toQueryValue($me);
        }
        // query params
        if ($descendants !== null) {
            $queryParams['descendants'] = $this->apiClient->getSerializer()->toQueryValue($descendants);
        }
        // query params
        if ($sub_tasks !== null) {
            $queryParams['subTasks'] = $this->apiClient->getSerializer()->toQueryValue($sub_tasks);
        }
        // query params
        if ($plain_text !== null) {
            $queryParams['plainText'] = $this->apiClient->getSerializer()->toQueryValue($plain_text);
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Wrike\Client\Model\InlineResponse2003',
                '/accounts/{accountId}/timelogs'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\Wrike\Client\Model\InlineResponse2003', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\InlineResponse2003', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getTimelogsForContact
     *
     * 
     *
     * @param string $contact_id The contact ID (required)
     * @param string $created_date Created date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $tracked_date Tracked date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $me If present - only contact info of requesting user is returned (optional)
     * @param bool $descendants Adds all descendant tasks to search scope (optional, default to true)
     * @param bool $sub_tasks Adds subtasks to search scope (optional, default to true)
     * @param bool $plain_text Get comment text as plain text, HTML otherwise (optional, default to false)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return \Wrike\Client\Model\InlineResponse2003
     */
    public function getTimelogsForContact($contact_id, $created_date = null, $tracked_date = null, $me = null, $descendants = null, $sub_tasks = null, $plain_text = null)
    {
        list($response) = $this->getTimelogsForContactWithHttpInfo($contact_id, $created_date, $tracked_date, $me, $descendants, $sub_tasks, $plain_text);
        return $response;
    }

    /**
     * Operation getTimelogsForContactWithHttpInfo
     *
     * 
     *
     * @param string $contact_id The contact ID (required)
     * @param string $created_date Created date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $tracked_date Tracked date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $me If present - only contact info of requesting user is returned (optional)
     * @param bool $descendants Adds all descendant tasks to search scope (optional, default to true)
     * @param bool $sub_tasks Adds subtasks to search scope (optional, default to true)
     * @param bool $plain_text Get comment text as plain text, HTML otherwise (optional, default to false)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return array of \Wrike\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTimelogsForContactWithHttpInfo($contact_id, $created_date = null, $tracked_date = null, $me = null, $descendants = null, $sub_tasks = null, $plain_text = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $contact_id when calling getTimelogsForContact');
        }
        // parse inputs
        $resourcePath = "/contacts/{contactId}/timelogs";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($created_date !== null) {
            $queryParams['createdDate'] = $this->apiClient->getSerializer()->toQueryValue($created_date);
        }
        // query params
        if ($tracked_date !== null) {
            $queryParams['trackedDate'] = $this->apiClient->getSerializer()->toQueryValue($tracked_date);
        }
        // query params
        if ($me !== null) {
            $queryParams['me'] = $this->apiClient->getSerializer()->toQueryValue($me);
        }
        // query params
        if ($descendants !== null) {
            $queryParams['descendants'] = $this->apiClient->getSerializer()->toQueryValue($descendants);
        }
        // query params
        if ($sub_tasks !== null) {
            $queryParams['subTasks'] = $this->apiClient->getSerializer()->toQueryValue($sub_tasks);
        }
        // query params
        if ($plain_text !== null) {
            $queryParams['plainText'] = $this->apiClient->getSerializer()->toQueryValue($plain_text);
        }
        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                "{" . "contactId" . "}",
                $this->apiClient->getSerializer()->toPathValue($contact_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Wrike\Client\Model\InlineResponse2003',
                '/contacts/{contactId}/timelogs'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\Wrike\Client\Model\InlineResponse2003', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\InlineResponse2003', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getTimelogsForFolder
     *
     * 
     *
     * @param string $folder_id The contact ID (required)
     * @param string $created_date Created date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $tracked_date Tracked date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $me If present - only contact info of requesting user is returned (optional)
     * @param bool $descendants Adds all descendant tasks to search scope (optional, default to true)
     * @param bool $sub_tasks Adds subtasks to search scope (optional, default to true)
     * @param bool $plain_text Get comment text as plain text, HTML otherwise (optional, default to false)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return \Wrike\Client\Model\InlineResponse2003
     */
    public function getTimelogsForFolder($folder_id, $created_date = null, $tracked_date = null, $me = null, $descendants = null, $sub_tasks = null, $plain_text = null)
    {
        list($response) = $this->getTimelogsForFolderWithHttpInfo($folder_id, $created_date, $tracked_date, $me, $descendants, $sub_tasks, $plain_text);
        return $response;
    }

    /**
     * Operation getTimelogsForFolderWithHttpInfo
     *
     * 
     *
     * @param string $folder_id The contact ID (required)
     * @param string $created_date Created date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $tracked_date Tracked date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $me If present - only contact info of requesting user is returned (optional)
     * @param bool $descendants Adds all descendant tasks to search scope (optional, default to true)
     * @param bool $sub_tasks Adds subtasks to search scope (optional, default to true)
     * @param bool $plain_text Get comment text as plain text, HTML otherwise (optional, default to false)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return array of \Wrike\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTimelogsForFolderWithHttpInfo($folder_id, $created_date = null, $tracked_date = null, $me = null, $descendants = null, $sub_tasks = null, $plain_text = null)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $folder_id when calling getTimelogsForFolder');
        }
        // parse inputs
        $resourcePath = "/folders/{folderId}/timelogs";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($created_date !== null) {
            $queryParams['createdDate'] = $this->apiClient->getSerializer()->toQueryValue($created_date);
        }
        // query params
        if ($tracked_date !== null) {
            $queryParams['trackedDate'] = $this->apiClient->getSerializer()->toQueryValue($tracked_date);
        }
        // query params
        if ($me !== null) {
            $queryParams['me'] = $this->apiClient->getSerializer()->toQueryValue($me);
        }
        // query params
        if ($descendants !== null) {
            $queryParams['descendants'] = $this->apiClient->getSerializer()->toQueryValue($descendants);
        }
        // query params
        if ($sub_tasks !== null) {
            $queryParams['subTasks'] = $this->apiClient->getSerializer()->toQueryValue($sub_tasks);
        }
        // query params
        if ($plain_text !== null) {
            $queryParams['plainText'] = $this->apiClient->getSerializer()->toQueryValue($plain_text);
        }
        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                "{" . "folderId" . "}",
                $this->apiClient->getSerializer()->toPathValue($folder_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Wrike\Client\Model\InlineResponse2003',
                '/folders/{folderId}/timelogs'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\Wrike\Client\Model\InlineResponse2003', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\InlineResponse2003', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getTimelogsForTask
     *
     * 
     *
     * @param string $task_id The contact ID (required)
     * @param string $created_date Created date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $tracked_date Tracked date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $me If present - only contact info of requesting user is returned (optional)
     * @param bool $descendants Adds all descendant tasks to search scope (optional, default to true)
     * @param bool $sub_tasks Adds subtasks to search scope (optional, default to true)
     * @param bool $plain_text Get comment text as plain text, HTML otherwise (optional, default to false)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return \Wrike\Client\Model\InlineResponse2003
     */
    public function getTimelogsForTask($task_id, $created_date = null, $tracked_date = null, $me = null, $descendants = null, $sub_tasks = null, $plain_text = null)
    {
        list($response) = $this->getTimelogsForTaskWithHttpInfo($task_id, $created_date, $tracked_date, $me, $descendants, $sub_tasks, $plain_text);
        return $response;
    }

    /**
     * Operation getTimelogsForTaskWithHttpInfo
     *
     * 
     *
     * @param string $task_id The contact ID (required)
     * @param string $created_date Created date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param string $tracked_date Tracked date filter, date match or range (Timestamp semi-open interval) \\n - start (Optional): Range start \\n - equal (Optional): Date exact match value \\n - end (Optional): Range end \\n \&quot;Format: yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39; (&#39;T&#39;HH:mm:ss is optional)\&quot; (optional)
     * @param bool $me If present - only contact info of requesting user is returned (optional)
     * @param bool $descendants Adds all descendant tasks to search scope (optional, default to true)
     * @param bool $sub_tasks Adds subtasks to search scope (optional, default to true)
     * @param bool $plain_text Get comment text as plain text, HTML otherwise (optional, default to false)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return array of \Wrike\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTimelogsForTaskWithHttpInfo($task_id, $created_date = null, $tracked_date = null, $me = null, $descendants = null, $sub_tasks = null, $plain_text = null)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $task_id when calling getTimelogsForTask');
        }
        // parse inputs
        $resourcePath = "/tasks/{taskId}/timelogs";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($created_date !== null) {
            $queryParams['createdDate'] = $this->apiClient->getSerializer()->toQueryValue($created_date);
        }
        // query params
        if ($tracked_date !== null) {
            $queryParams['trackedDate'] = $this->apiClient->getSerializer()->toQueryValue($tracked_date);
        }
        // query params
        if ($me !== null) {
            $queryParams['me'] = $this->apiClient->getSerializer()->toQueryValue($me);
        }
        // query params
        if ($descendants !== null) {
            $queryParams['descendants'] = $this->apiClient->getSerializer()->toQueryValue($descendants);
        }
        // query params
        if ($sub_tasks !== null) {
            $queryParams['subTasks'] = $this->apiClient->getSerializer()->toQueryValue($sub_tasks);
        }
        // query params
        if ($plain_text !== null) {
            $queryParams['plainText'] = $this->apiClient->getSerializer()->toQueryValue($plain_text);
        }
        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                "{" . "taskId" . "}",
                $this->apiClient->getSerializer()->toPathValue($task_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Wrike\Client\Model\InlineResponse2003',
                '/tasks/{taskId}/timelogs'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\Wrike\Client\Model\InlineResponse2003', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\InlineResponse2003', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateMyContact
     *
     * 
     *
     * @param string $contact_id The contact ID (required)
     * @param string $metadata Metadata filter, exact match for metadata key or key-value pair (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return \Wrike\Client\Model\InlineResponse200
     */
    public function updateMyContact($contact_id, $metadata = null)
    {
        list($response) = $this->updateMyContactWithHttpInfo($contact_id, $metadata);
        return $response;
    }

    /**
     * Operation updateMyContactWithHttpInfo
     *
     * 
     *
     * @param string $contact_id The contact ID (required)
     * @param string $metadata Metadata filter, exact match for metadata key or key-value pair (optional)
     * @throws \Wrike\Client\ApiException on non-2xx response
     * @return array of \Wrike\Client\Model\InlineResponse200, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMyContactWithHttpInfo($contact_id, $metadata = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $contact_id when calling updateMyContact');
        }
        // parse inputs
        $resourcePath = "/contacts/{contactId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/x-www-form-urlencoded']);

        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                "{" . "contactId" . "}",
                $this->apiClient->getSerializer()->toPathValue($contact_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($metadata !== null) {
            $formParams['metadata'] = $this->apiClient->getSerializer()->toFormValue($metadata);
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\Wrike\Client\Model\InlineResponse200',
                '/contacts/{contactId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\Wrike\Client\Model\InlineResponse200', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\InlineResponse200', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 0:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\Wrike\Client\Model\Error', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
}
